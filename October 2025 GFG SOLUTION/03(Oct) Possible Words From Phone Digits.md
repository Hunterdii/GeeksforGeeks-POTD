---
title: "ğŸ“± Possible Words From Phone Digits | GFG Solution ğŸ”"
keywordsğŸ·ï¸: ["ğŸ“± phone keypad", "ğŸ” backtracking", "ğŸ“ combinations", "ğŸ“ˆ iterative build", "ğŸ“˜ GFG", "ğŸ competitive programming", "ğŸ“š DSA"]
author: "âœï¸ Het Patel (Hunterdii)"
description: "âœ… GFG solution to the Possible Words From Phone Digits problem: generate all possible letter combinations from phone keypad digits using iterative and backtracking approaches. ğŸš€"
date: ğŸ“… 2025-10-03
---

# *03. Possible Words From Phone Digits*

The problem can be found at the following link: ğŸ”— [Question Link](https://www.geeksforgeeks.org/problems/possible-words-from-phone-digits-1587115620/1)

## **ğŸ§© Problem Description**

You are given a keypad (as shown in the diagram) and an array `arr[]` containing digits. Your task is to list all possible words in any order which can be generated by pressing numbers in `arr[]` sequentially.

**Note:** Number 0 and 1 do not map to any letters. You can return the words in any order, the driver code will print them in sorted order.

## **ğŸ“˜ Examples**

### Example 1

```cpp
Input: arr[] = [2, 3]
Output: [ad, ae, af, bd, be, bf, cd, ce, cf]
Explanation: When we press 2 and 3 total 3 x 3 = 9 possible words formed.
```

### Example 2

```cpp
Input: arr[] = [2]
Output: [a, b, c]
Explanation: When we press 2 total 3 possible words formed.
```

## **ğŸ”’ Constraints**

* $1 \le \text{arr.size()} \le 9$
* $0 \le \text{arr}[i] \le 9$

## **âœ… My Approach**

The optimal approach uses an **Iterative Build-Up** technique to generate all possible letter combinations:

### **Iterative Cross-Product Generation**

1. **Initialize:**
   * Create a keypad mapping array where index represents digit and value contains corresponding letters.
   * Start with a result vector containing an empty string `[""]`.

2. **Process Each Digit:**
   * For each digit in the input array, skip if it's 0 or 1 (no letter mapping).
   * Create a temporary vector to store new combinations.

3. **Generate Combinations:**
   * For each existing string in the result vector, append each possible character from the current digit's letter mapping.
   * Use cross-product logic: if current result has `m` strings and digit has `k` letters, generate `m Ã— k` new combinations.

4. **Update Result:**
   * Replace the result vector with the newly generated combinations using move semantics for efficiency.

5. **Return Final Result:**
   * After processing all digits, return the complete list of combinations.

## ğŸ“ Time and Auxiliary Space Complexity

* **Expected Time Complexity:** O(4^n Ã— n), where n is the number of valid digits (2-9) in the array. In the worst case, each digit can map to 4 characters (like 7 and 9), and we generate 4^n combinations. Each combination takes O(n) time to build as we concatenate characters.
* **Expected Auxiliary Space Complexity:** O(4^n Ã— n), as we store all possible combinations in the result vector. Each combination string has length up to n characters.


## **ğŸ§‘â€ğŸ’» Code (C++)**

```cpp
class Solution {
public:
    vector<string> possibleWords(vector<int> &arr) {
        vector<string> res = {""};
        string keys[] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        for (int d : arr) {
            if (d < 2 || d > 9) continue;
            vector<string> temp;
            for (string &s : res)
                for (char c : keys[d])
                    temp.push_back(s + c);
            res = move(temp);
        }
        return res;
    }
};
```

<details>
<summary><b>âš¡ View Alternative Approaches with Code and Analysis</b></summary>

## ğŸ“Š **2ï¸âƒ£ Backtracking Approach**

### ğŸ’¡ Algorithm Steps:

1. Use recursive backtracking to build combinations one character at a time.
2. For each digit, iterate through its mapped characters.
3. Add character to current string and recurse to next digit.
4. Backtrack by removing the last character after exploring all paths.

```cpp
class Solution {
    void solve(vector<int> &arr, int i, string cur, string keys[], vector<string> &ans) {
        if (i == arr.size()) { ans.push_back(cur); return; }
        if (arr[i] < 2 || arr[i] > 9) { solve(arr, i + 1, cur, keys, ans); return; }
        for (char c : keys[arr[i]]) solve(arr, i + 1, cur + c, keys, ans);
    }
public:
    vector<string> possibleWords(vector<int> &arr) {
        vector<string> ans;
        string keys[] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        solve(arr, 0, "", keys, ans);
        return ans;
    }
};
```

### ğŸ“ **Complexity Analysis:**

* **Time:** â±ï¸ O(4^n) - Up to 4 characters per digit (worst case)
* **Auxiliary Space:** ğŸ’¾ O(n) - Recursion stack depth

### âœ… **Why This Approach?**

* Classic recursive pattern for combinations
* Easy to understand and debug
* Natural fit for tree exploration problems

## ğŸ“Š **3ï¸âƒ£ Queue-Based BFS**

### ğŸ’¡ Algorithm Steps:

1. Use a queue to build combinations level by level (breadth-first).
2. Start with an empty string in the queue.
3. For each digit, process all current combinations and append each possible character.
4. Continue until all digits are processed.

```cpp
class Solution {
public:
    vector<string> possibleWords(vector<int> &arr) {
        queue<string> q;
        q.push("");
        string keys[] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        for (int d : arr) {
            if (d < 2 || d > 9) continue;
            int sz = q.size();
            while (sz--) {
                string cur = q.front(); q.pop();
                for (char c : keys[d]) q.push(cur + c);
            }
        }
        vector<string> res;
        while (!q.empty()) { res.push_back(q.front()); q.pop(); }
        return res;
    }
};
```

### ğŸ“ **Complexity Analysis:**

* **Time:** â±ï¸ O(4^n) - Generate all possible combinations
* **Auxiliary Space:** ğŸ’¾ O(4^n) - Queue stores all intermediate combinations

### âœ… **Why This Approach?**

* Level-by-level construction for clear visualization
* Avoids recursion overhead
* Good for understanding combination generation process

## ğŸ“Š **4ï¸âƒ£ Dynamic Programming Build-Up**

### ğŸ’¡ Algorithm Steps:

1. Build combinations iteratively using dynamic programming concept.
2. Maintain current set of combinations and update for each digit.
3. For each new digit, cross-product current results with digit's characters.
4. Replace old results with newly formed combinations.

```cpp
class Solution {
public:
    vector<string> possibleWords(vector<int> &arr) {
        string keys[] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        vector<string> dp = {""};
        for (int d : arr) {
            if (d < 2 || d > 9) continue;
            vector<string> next;
            next.reserve(dp.size() * keys[d].size());
            for (const string &s : dp)
                for (char c : keys[d])
                    next.push_back(s + c);
            dp = move(next);
        }
        return dp;
    }
};
```

### ğŸ“ **Complexity Analysis:**

* **Time:** â±ï¸ O(4^n) - Generate all combinations
* **Auxiliary Space:** ğŸ’¾ O(4^n) - Store all combinations

### âœ… **Why This Approach?**

* Iterative solution avoiding recursion
* Memory pre-allocation with reserve() for efficiency
* Clean separation of digit processing logic

## ğŸ†š **ğŸ” Comparison of Approaches**

| ğŸš€ **Approach**                    | â±ï¸ **Time Complexity** | ğŸ’¾ **Space Complexity** | âœ… **Pros**                        | âš ï¸ **Cons**                           |
| ---------------------------------- | ---------------------- | ----------------------- | --------------------------------- | ------------------------------------- |
| ğŸ·ï¸ **Iterative Build**            | ğŸŸ¢ O(4^n)              | ğŸŸ¢ O(4^n)               | ğŸš€ Fast with move semantics       | ğŸ’¾ Creates temporary vectors         |
| ğŸ” **Backtracking**               | ğŸŸ¢ O(4^n)              | ğŸŸ¢ O(n)                 | ğŸ“– Intuitive recursive pattern    | ğŸ”„ Function call overhead            |
| ğŸ“Š **Queue BFS**                  | ğŸŸ¢ O(4^n)              | ğŸŸ¡ O(4^n)               | ğŸ¯ Level-by-level clarity         | ğŸ’¾ Queue memory overhead             |
| ğŸ”„ **DP Build-Up**                | ğŸŸ¢ O(4^n)              | ğŸŸ¢ O(4^n)               | â­ Memory pre-allocation          | ğŸ”§ Similar to iterative              |

### ğŸ† **Best Choice Recommendation**

| ğŸ¯ **Scenario**                                    | ğŸ–ï¸ **Recommended Approach**          | ğŸ”¥ **Performance Rating** |
| -------------------------------------------------- | ------------------------------------- | ------------------------- |
| ğŸ… **Optimal performance needed**                     | ğŸ¥‡ **Iterative Build**               | â˜…â˜…â˜…â˜…â˜…                     |
| ğŸ“– **Readability priority**                           | ğŸ¥ˆ **Backtracking**                  | â˜…â˜…â˜…â˜…â˜…                     |
| ğŸ”§ **Understanding combinations**                     | ğŸ¥‰ **Queue BFS**                     | â˜…â˜…â˜…â˜…â˜†                     |
| ğŸ¯ **Interview/Competitive**                          | ğŸ… **DP Build-Up**                   | â˜…â˜…â˜…â˜…â˜…                     |

</details>

## **â˜• Code (Java)**

```java
class Solution {
    public ArrayList<String> possibleWords(int[] arr) {
        ArrayList<String> res = new ArrayList<>();
        res.add("");
        String[] keys = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        for (int d : arr) {
            if (d < 2 || d > 9) continue;
            ArrayList<String> temp = new ArrayList<>();
            for (String s : res)
                for (char c : keys[d].toCharArray())
                    temp.add(s + c);
            res = temp;
        }
        return res;
    }
}
```

## **ğŸ Code (Python)**

```python
class Solution:
    def possibleWords(self, arr):
        res = [""]
        keys = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        for d in arr:
            if d < 2 or d > 9: continue
            res = [s + c for s in res for c in keys[d]]
        return res
```


## ğŸ§  Contribution and Support

For discussions, questions, or doubts related to this solution, feel free to connect on LinkedIn: [ğŸ“¬ Any Questions?](https://www.linkedin.com/in/patel-hetkumar-sandipbhai-8b110525a/). Let's make this learning journey more collaborative!

â­ **If you find this helpful, please give this repository a star!** â­

---

<div align="center">
  <h3><b>ğŸ“Visitor Count</b></h3>
</div>

<p align="center">
  <img src="https://visitor-badge.laobi.icu/badge?page_id=Hunterdii.GeeksforGeeks-POTD" alt="Visitor counter" />
</p>
